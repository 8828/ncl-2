C
C $Id: cptroe.f,v 1.4 1994-09-12 22:10:56 kennison Exp $
C
      SUBROUTINE CPTROE (XCRA,YCRA,NCRA,OFFS,RWRK,IOCF,IAMA,IGID,IAIL,
     +                                                           IAIR)
C
      DIMENSION XCRA(*),YCRA(*),RWRK(8),IAMA(*)
C
C The routine CPTROE is given the (fractional) X and Y coordinates of
C points defining a curve C.  It generates a curve C' which is parallel
C to C and separated from it by a small distance.  The points defining
C C' are passed on to the routine CPWLAM, which clips them against a
C rectangular window (defined by the contents of the common block
C WDCOMN) and passes the visible portions on to AREDAM for insertion
C in an area map.
C
C XCRA and YCRA are X and Y coordinate arrays defining NCRA points that
C define part of the curve C.  OFFS is the distance, in the fractional
C coordinate system, from C to C'; if OFFS is positive, C' is to the
C left of C and, if OFFS is negative, C' is to the right of C.  RWRK is
C a workspace array, dimensioned 8, in which required X/Y coordinates
C can be saved from call to call.  (It is expected, for a given curve,
C that the last point in one call will be the first point in the next
C call; if the curve is closed, it is expected that the last point in
C the last call will match the first point in the first call.  Still,
C we need to save the next-to-last point from each call for use during
C the next call and, if the curve is closed, we need to save the second
C and third points from the first call for use during the last call.
C We also need to save the last offset curve point generated by each
C call except the last. The saves could be done using local SAVEd
C variables, but that would preclude generating curves for positive
C and negative values of OFFS at the same time.)  IOCF is a flag of
C the form
C
C     4 * R + 2 * S + T
C
C where R, S, and T are one-bit flags giving information about the part
C of C defined by the call.  R = 0 says that (XCRA(NCRA),YCRA(NCRA))
C is not the last point of C and R = 1 says that it is.  S = 0 says that
C (XCRA(1),YCRA(1)) is the first point of the curve and S = 1 says that
C it is not.  T = 0 says that C is open on both ends, in which case its
C ends are to be extended to intersect the edges of the plotter frame,
C and T = 1 says that C is closed on itself.  IAMA is an area map array.
C IGID is the group identifier and IAIL and IAIR are the left and right
C area identifiers to be passed on to CPWLAM and eventually to AREDAM.
C
C Note that, in the sequence of calls to CPTROE for a particular curve,
C IOCF takes on values like the following:
C
C     0  =>  Beginning of an open curve.
C     1  =>  Beginning of a closed curve.
C     2  =>  Part of an open curve, not including either end point.
C     3  =>  Part of a closed curve, not including either end point.
C     4  =>  End of an open curve.
C     5  =>  End of a closed curve.
C     6  =>  An entire open curve, including both end points.
C     7  =>  An entire closed curve, including both end points.
C
C First, extract individual flags from IOCF.  IBEG says whether or not
C the curve begins with this call, IEND says whether or not the curve
C ends with this call, and ICLO says whether or not the curve is closed.
C
      IBEG=1-MOD(IOCF/2,2)
      IEND=IOCF/4
      ICLO=MOD(IOCF,2)
C
C Initialize the flag that tells CPWLAM whether it just got a first
C point or not.
C
      IFST=0
C
C Do necessary initialization.
C
      IF (IBEG.NE.0) THEN
        ICRA=1
        XCPB=XCRA(1)
        YCPB=YCRA(1)
        XCPC=XCRA(2)
        YCPC=YCRA(2)
        IF (ICLO.EQ.0) THEN
          DIRE=0.
          ASSIGN 101 TO IJMP
          GO TO 201
        ELSE
          RWRK(1)=XCRA(2)
          RWRK(2)=YCRA(2)
          RWRK(3)=XCRA(3)
          RWRK(4)=YCRA(3)
        END IF
      ELSE
        CALL CPWLAM (RWRK(7),RWRK(8),IFST,IAMA,IGID,IAIL,IAIR)
        IF (ICFELL('CPTROE',1).NE.0) RETURN
        IFST=1
        ICRA=0
        XCPB=RWRK(5)
        YCPB=RWRK(6)
        XCPC=XCRA(1)
        YCPC=YCRA(1)
      END IF
C
C Generate offset points near the point with index ICRA until ICRA
C becomes equal to NCRA.
C
  101 ASSIGN 102 TO IJMP
C
  102 ICRA=ICRA+1
      IF (ICRA.LT.NCRA) THEN
        XCPA=XCPB
        YCPA=YCPB
        XCPB=XCPC
        YCPB=YCPC
        XCPC=XCRA(ICRA+1)
        YCPC=YCRA(ICRA+1)
        GO TO 301
      END IF
C
C Do necessary final stuff.
C
      IF (IEND.EQ.0) THEN
        RWRK(5)=XCRA(NCRA-1)
        RWRK(6)=YCRA(NCRA-1)
        RWRK(7)=XNXT
        RWRK(8)=YNXT
        GO TO 104
      ELSE
        IF (ICLO.EQ.0) THEN
          DIRE=1.
          ASSIGN 104 TO IJMP
          GO TO 201
        ELSE
          XCPA=XCPB
          YCPA=YCPB
          XCPB=XCPC
          YCPB=YCPC
          XCPC=RWRK(1)
          YCPC=RWRK(2)
          ASSIGN 103 TO IJMP
          GO TO 301
        END IF
      END IF
C
  103 XCPA=XCPB
      YCPA=YCPB
      XCPB=XCPC
      YCPB=YCPC
      XCPC=RWRK(3)
      YCPC=RWRK(4)
      ASSIGN 104 TO IJMP
      GO TO 301
C
C Done.
C
  104 RETURN
C
C The following internal procedure generates the point of intersection
C of the line offset from BC with the edge of the plotter frame and
C sends that point off to CPWLAM.  DIRE says whether we want the point
C of intersection nearer to B (DIRE = 0.) or nearer to C (DIRE = 1.).
C
  201 XDBC=XCPC-XCPB
      YDBC=YCPC-YCPB
      DFBC=SQRT(XDBC*XDBC+YDBC*YDBC)
      XCPP=XCPB-OFFS*YDBC/DFBC
      YCPP=YCPB+OFFS*XDBC/DFBC
      XCPQ=XCPC-OFFS*YDBC/DFBC
      YCPQ=YCPC+OFFS*XDBC/DFBC
      IF (ABS(XDBC).GT.ABS(YDBC)) THEN
        IF (XDBC.GT.0.) THEN
          XNXT=DIRE
        ELSE
          XNXT=1.-DIRE
        END IF
        YNXT=YCPP+(XNXT-XCPP)*(YDBC/XDBC)
      ELSE
        IF (YDBC.GT.0.) THEN
          YNXT=DIRE
        ELSE
          YNXT=1.-DIRE
        END IF
        XNXT=XCPP+(YNXT-YCPP)*(XDBC/YDBC)
      END IF
      CALL CPWLAM (XNXT,YNXT,IFST,IAMA,IGID,IAIL,IAIR)
      IF (ICFELL('CPTROE',2).NE.0) RETURN
      IFST=1
      GO TO IJMP , (101,104)
C
C The following internal procedure generates the point of intersection
C of the line offset from AB with the line offset from BC and sends that
C point off to CPWLAM.
C
  301 XDAB=XCPB-XCPA
      YDAB=YCPB-YCPA
      DFAB=SQRT(XDAB*XDAB+YDAB*YDAB)
      XCPP=XCPA-OFFS*YDAB/DFAB
      YCPP=YCPA+OFFS*XDAB/DFAB
      XCPQ=XCPB-OFFS*YDAB/DFAB
      YCPQ=YCPB+OFFS*XDAB/DFAB
      XDBC=XCPC-XCPB
      YDBC=YCPC-YCPB
      DFBC=SQRT(XDBC*XDBC+YDBC*YDBC)
      XCPR=XCPB-OFFS*YDBC/DFBC
      YCPR=YCPB+OFFS*XDBC/DFBC
      XCPS=XCPC-OFFS*YDBC/DFBC
      YCPS=YCPC+OFFS*XDBC/DFBC
      DNOM=(XCPP-XCPQ)*(YCPR-YCPS)-(XCPR-XCPS)*(YCPP-YCPQ)
      IF (DNOM.EQ.0.) THEN
        XNXT=.5*(XCPQ+XCPR)
        YNXT=.5*(YCPQ+YCPR)
      ELSE
        TEMP=((XCPP-XCPR)*(YCPR-YCPS)-(XCPR-XCPS)*(YCPP-YCPR))/DNOM
        XNXT=XCPP+(XCPQ-XCPP)*TEMP
        YNXT=YCPP+(YCPQ-YCPP)*TEMP
      END IF
      CALL CPWLAM (XNXT,YNXT,IFST,IAMA,IGID,IAIL,IAIR)
      IF (ICFELL('CPTROE',3).NE.0) RETURN
      IFST=1
      GO TO IJMP , (102,103,104)
C
      END
