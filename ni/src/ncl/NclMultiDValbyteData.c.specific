
/*
 *      $Id: NclMultiDValbyteData.c.specific,v 1.4 1994-12-23 01:18:38 ethan Exp $
 */
/************************************************************************
*									*
*			     Copyright (C)  1994			*
*	     University Corporation for Atmospheric Research		*
*			     All Rights Reserved			*
*									*
************************************************************************/
/*
 *	File:		
 *
 *	Author:		Ethan Alpert
 *			National Center for Atmospheric Research
 *			PO 3000, Boulder, Colorado
 *
 *	Date:		Thu Jan 13 14:56:13 MST 1994
 *
 *	Description:	
 */
#include "NclMultiDValfloatData.h"
#include "NclMultiDVallogicalData.h"
static NclData MultiDVal_byte_md_Coerce
#if	NhlNeedProto
(NclData  self, NclObjTypes coerce_to_obj, NclScalar* new_missing)
#else
(self, coerce_to_obj, new_missing)
	NclData  self;
	NclObjTypes coerce_to_obj;
	NclScalar *new_missing;
#endif
{
	NclMultiDValbyteData self_md = (NclMultiDValbyteData)self;
	logical *lovalue;
	NclData output_md;
	NclScalar missing;
	int i,chckmiss = 0;

	
	if(self_md->obj.obj_type == Ncl_MultiDValbyteData) {
		if((new_missing == NULL)||(!self_md->multidval.missing_value.has_missing)) {
			return(self);
		} else if(self_md->multidval.missing_value.value.byteval != new_missing->byteval) {
			if(self->obj.status == TEMPORARY) {
/*
* This avoids a new allocation and copy but probably costs more time
*/
				_NclResetMissingValue((NclMultiDValData)self,new_missing);
				return(self);
			} else {
				return((NclData)_NclCopyVal((NclMultiDValData)self,new_missing));
			}
		} else {
				return(self);
		}
	} if(coerce_to_obj == Ncl_MultiDVallogicalData) {
		lovalue = (logical*)NclMalloc((unsigned)sizeof(logical)*
                        self_md->multidval.totalelements);
                if(self_md->multidval.missing_value.has_missing) {
                        if(new_missing == NULL) {
                                missing.logicalval = (logical)
                                        self_md->multidval.missing_value.value.byteval;
                        } else {
                                chckmiss = 1;
                                missing = self_md->multidval.missing_value.value;
                        }
                }
                if(chckmiss) {
                        for(i=0; i<self_md->multidval.totalelements;i++) {
                                lovalue[i] = (logical)(
                                ((int*)self_md->multidval.val)[i] == missing.byteval ? new_missing->logicalval : (((byte*)self_md->multidval.val)[i] ? 1 : 0));
                        }
                } else {
                        for(i=0; i<self_md->multidval.totalelements;i++) {
                                lovalue[i] = (logical)(((byte*)self_md->multidval.val)[i]?1:0);
                        }
                }
                if(new_missing != NULL) {
                        missing = *new_missing;
                }
                output_md = (NclData)_NclMultiDVallogicalCreate(NULL,NULL,Ncl_MultiDVallogicalData,0,(void*)lovalue,
                ((self_md->multidval.missing_value.has_missing||new_missing!=NULL) ? &missing:NULL),
                        self_md->multidval.n_dims,
                        self_md->multidval.dim_sizes,
                        TEMPORARY,NULL);
                return((NclData)output_md);

	} else {
		return(NULL);
	}
}

static NclData MultiDVal_byte_s_Coerce
#if	NhlNeedProto
(NclData self, NclObjTypes coerce_to_obj, NclScalar* new_missing)
#else
(self, coerce_to_obj,new_missing)
NclData self;
NclObjTypes coerce_to_obj;
NclScalar *new_missing;
#endif
{
	NclMultiDValbyteData self_md = (NclMultiDValbyteData)self;
	NclData output_md;
	NclScalar missing;
	int chckmiss = 0;

	logical *lovalue;
	if(self_md->obj.obj_type == Ncl_MultiDValbyteData) {
		if((new_missing == NULL )||(!self_md->multidval.missing_value.has_missing)) {
			return(self);
		}  else if(new_missing->byteval != self_md->multidval.missing_value.value.byteval){
			if(self->obj.status == TEMPORARY) {
/*
* This avoids a new allocation and copy but probably costs more time
*/
				_NclResetMissingValue((NclMultiDValData)self,new_missing);
				return(self);
			} else {
				return((NclData)_NclCopyVal((NclMultiDValData)self,new_missing));
			}
		} else {
			return(self);
		}
	} if(coerce_to_obj == Ncl_MultiDVallogicalData) {
		lovalue = (logical*)NclMalloc((unsigned)sizeof(logical));
                if(self_md->multidval.missing_value.has_missing) {
                        if(new_missing == NULL) {
                                missing.logicalval = (logical)
                                        self_md->multidval.missing_value.value.byteval;
                        } else {
                                chckmiss = 1;
                                missing = self_md->multidval.missing_value.value;
                        }
                }
                if(chckmiss) {
                        *lovalue = (logical) (
                                        *((logical*)self_md->multidval.val) == missing.byteval ?
                                        new_missing->logicalval:
                                        (*((byte*)self_md->multidval.val)?1:0)
                                );
                } else{
                        *lovalue = (logical)(*((byte*)self_md->multidval.val)?1:0);
                }
                if(new_missing != NULL)
                        missing = *new_missing;
                output_md = (NclData)_NclMultiDVallogicalCreate(NULL,
                        NULL,Ncl_MultiDVallogicalData,0,
                        (void*)lovalue,
                ((self_md->multidval.missing_value.has_missing||new_missing!=NULL) ? &missing:NULL),
                        self_md->multidval.n_dims,
                        self_md->multidval.dim_sizes,
                        TEMPORARY,NULL);
                return((NclData)output_md);

	} else {
		return(NULL);
	}
}
